<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Property Hologram - CLUES Quantum Intelligence</title>

    <!-- CLUES Core Systems -->
    <script src="core/data-manager.js"></script>
    <script src="core/scoring-engine.js"></script>
    <script src="shared-data-adapter.js"></script>

    <!-- Three.js r158 -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="lib/OrbitControls.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a1628, #1a2847);
            color: white;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 300px;
        }

        .hud h1 {
            font-size: 1.5em;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #00D4FF, #00FF88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .property-selector {
            margin: 10px 0;
        }

        .property-selector label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            opacity: 0.9;
        }

        .property-selector select {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 0.9em;
        }

        .mode-toggle {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid rgba(0, 212, 255, 0.4);
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .mode-toggle:hover {
            background: rgba(0, 212, 255, 0.3);
            transform: translateY(-2px);
        }

        .voice-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.2);
            backdrop-filter: blur(20px);
            padding: 15px 30px;
            border-radius: 50px;
            border: 2px solid rgba(255, 0, 0, 0.5);
            display: none;
            animation: pulse 1.5s infinite;
        }

        .voice-indicator.active {
            display: block;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; transform: translateX(-50%) scale(1); }
            50% { opacity: 1; transform: translateX(-50%) scale(1.05); }
        }

        .overlay-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(15px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(0, 212, 255, 0.4);
            max-width: 250px;
        }

        .overlay-panel h3 {
            font-size: 1em;
            margin-bottom: 10px;
            color: #00D4FF;
        }

        .stat-item {
            margin: 8px 0;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
        }

        .back-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="hud">
        <h1>üè† 3D Property Hologram</h1>

        <div class="property-selector">
            <label>Property A:</label>
            <select id="propertyA" onchange="loadProperty('A', this.value)">
                <option value="">Select property...</option>
            </select>
        </div>

        <div class="property-selector">
            <label>Property B:</label>
            <select id="propertyB" onchange="loadProperty('B', this.value)">
                <option value="">Select property...</option>
            </select>
        </div>

        <div class="property-selector">
            <label>Property C:</label>
            <select id="propertyC" onchange="loadProperty('C', this.value)">
                <option value="">Select property...</option>
            </select>
        </div>

        <div class="mode-toggle" onclick="toggleViewMode()">
            <span id="mode-text">üìä Sphere Mode</span>
        </div>

        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.2);">
            <h3 style="font-size: 0.9em; margin-bottom: 10px; opacity: 0.8;">Overlays:</h3>
            <label style="display: flex; align-items: center; margin: 8px 0; cursor: pointer;">
                <input type="checkbox" id="crime-overlay" onchange="toggleOverlay('crime', this.checked)" checked style="margin-right: 8px;">
                <span>üö® Crime Heatmap</span>
            </label>
            <label style="display: flex; align-items: center; margin: 8px 0; cursor: pointer;">
                <input type="checkbox" id="schools-overlay" onchange="toggleOverlay('schools', this.checked)" checked style="margin-right: 8px;">
                <span>‚≠ê School Quality</span>
            </label>
            <label style="display: flex; align-items: center; margin: 8px 0; cursor: pointer;">
                <input type="checkbox" id="weather-overlay" onchange="toggleOverlay('weather', this.checked)" checked style="margin-right: 8px;">
                <span>üå¶Ô∏è Weather Effects</span>
            </label>
        </div>
    </div>

    <div class="voice-indicator" id="voice-indicator">
        üé§ Listening...
    </div>

    <div class="overlay-panel" id="overlay-panel" style="display: none;">
        <h3 id="overlay-title">Property Details</h3>
        <div id="overlay-content"></div>
    </div>

    <button class="back-btn" onclick="goBack()">‚Üê Back</button>

    <script>
        (function() {
            'use strict';

            // ===== GLOBAL VARIABLES =====
            let scene, camera, renderer, controls;
            let propertyModels = { A: null, B: null, C: null };
            let PROPERTIES = [];
            let viewMode = 'sphere'; // 'sphere' or '3d-model'
            let recognition = null;

            // ===== INITIALIZATION =====
            async function init() {
                console.log('üöÄ Initializing 3D Property Hologram...');

                // Initialize Three.js scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a1628);
                scene.fog = new THREE.Fog(0x0a1628, 10, 50);

                // Camera setup
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.set(0, 2, 10);

                // Renderer setup
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                // Controls
                if (typeof THREE.OrbitControls !== 'undefined') {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                }

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                // Ground plane
                const groundGeometry = new THREE.PlaneGeometry(50, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a2847,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -2;
                ground.receiveShadow = true;
                scene.add(ground);

                // Grid helper
                const gridHelper = new THREE.GridHelper(50, 50, 0x00D4FF, 0x1a2847);
                gridHelper.position.y = -1.99;
                scene.add(gridHelper);

                // Initialize CLUES data
                await initializeData();

                // Initialize voice commands
                initializeVoiceCommands();

                // Create initial placeholder spheres
                createPlaceholderSpheres();

                // Initialize weather system
                createWeatherSystem();

                // Start animation loop
                animate();

                // Event listeners
                window.addEventListener('resize', onWindowResize);

                console.log('‚úÖ 3D Property Hologram initialized');
            }

            async function initializeData() {
                try {
                    if (typeof dataManager === 'undefined') {
                        console.warn('Data manager not available, using demo data');
                        PROPERTIES = generateDemoProperties();
                        return;
                    }

                    await dataManager.init();
                    const cluesProperties = await dataManager.getAllProperties();

                    PROPERTIES = cluesProperties.map(mapCLUESProperty).filter(p => p !== null);

                    if (PROPERTIES.length === 0) {
                        PROPERTIES = generateDemoProperties();
                    }

                    populateSelectors();
                } catch (error) {
                    console.error('Error loading data:', error);
                    PROPERTIES = generateDemoProperties();
                    populateSelectors();
                }
            }

            function mapCLUESProperty(cluesProperty) {
                const scores = cluesProperty.computed_scores || {};
                const byCategory = scores.by_category || {};

                return {
                    id: cluesProperty.id,
                    name: cluesProperty.address?.full_address || 'Unknown Property',
                    price: cluesProperty.price?.current || 0,
                    modelUrl: cluesProperty.model3D?.url || null,
                    photos: cluesProperty.photos || [],
                    sqft: cluesProperty.basic?.squareFeet || 2000,
                    bedrooms: cluesProperty.basic?.bedrooms || 3,
                    bathrooms: cluesProperty.basic?.bathrooms || 2,
                    yearBuilt: cluesProperty.basic?.yearBuilt || 2000,
                    overallScore: scores.overall || Math.random() * 30 + 70,
                    crimeScore: 100 - (cluesProperty.location?.crimeRate || 20),
                    schoolRating: Math.floor((cluesProperty.schools?.averageRating || 4) * 2),
                    costOfLiving: byCategory.cost_of_living?.score || Math.random() * 100
                };
            }

            function generateDemoProperties() {
                return [
                    { id: 'demo1', name: 'Modern Villa', price: 2500000, modelUrl: null, photos: [], sqft: 3500, bedrooms: 4, bathrooms: 3, yearBuilt: 2020, overallScore: 92, crimeScore: 88, schoolRating: 9, costOfLiving: 75 },
                    { id: 'demo2', name: 'Downtown Loft', price: 950000, modelUrl: null, photos: [], sqft: 1800, bedrooms: 2, bathrooms: 2, yearBuilt: 2018, overallScore: 85, crimeScore: 70, schoolRating: 7, costOfLiving: 45 },
                    { id: 'demo3', name: 'Suburban Home', price: 650000, modelUrl: null, photos: [], sqft: 2400, bedrooms: 3, bathrooms: 2.5, yearBuilt: 2015, overallScore: 78, crimeScore: 92, schoolRating: 8, costOfLiving: 30 }
                ];
            }

            function populateSelectors() {
                ['propertyA', 'propertyB', 'propertyC'].forEach(selectId => {
                    const select = document.getElementById(selectId);
                    select.innerHTML = '<option value="">Select property...</option>';
                    PROPERTIES.forEach(prop => {
                        const option = document.createElement('option');
                        option.value = prop.id;
                        option.textContent = `${prop.name} - $${(prop.price / 1000).toFixed(0)}K`;
                        select.appendChild(option);
                    });
                });
            }

            // ===== 3D MODEL LOADING =====
            function createPlaceholderSpheres() {
                const positions = [
                    { x: -6, z: 0 },   // Property A (left)
                    { x: 0, z: 0 },    // Property B (center)
                    { x: 6, z: 0 }     // Property C (right)
                ];

                const colors = [0x00D4FF, 0x00FF88, 0xFFD700];

                positions.forEach((pos, idx) => {
                    const geometry = new THREE.SphereGeometry(1, 32, 32);
                    const material = new THREE.MeshPhongMaterial({
                        color: colors[idx],
                        emissive: colors[idx],
                        emissiveIntensity: 0.2,
                        transparent: true,
                        opacity: 0.3
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(pos.x, 0, pos.z);
                    sphere.castShadow = true;
                    sphere.receiveShadow = true;
                    scene.add(sphere);

                    const slot = ['A', 'B', 'C'][idx];
                    propertyModels[slot] = sphere;
                });
            }

            window.loadProperty = async function(slot, propertyId) {
                if (!propertyId) {
                    // Clear property
                    if (propertyModels[slot]) {
                        scene.remove(propertyModels[slot]);
                        propertyModels[slot] = null;
                    }
                    return;
                }

                const property = PROPERTIES.find(p => p.id === propertyId);
                if (!property) return;

                console.log(`Loading property ${slot}:`, property.name);

                // Remove existing model
                if (propertyModels[slot]) {
                    scene.remove(propertyModels[slot]);
                }

                if (viewMode === '3d-model') {
                    // TODO: Load actual 3D model
                    createProceduralHouse(slot, property);
                } else {
                    // Create sphere
                    const positions = { A: -6, B: 0, C: 6 };
                    const colors = { A: 0x00D4FF, B: 0x00FF88, C: 0xFFD700 };

                    const geometry = new THREE.SphereGeometry(1, 32, 32);
                    const material = new THREE.MeshPhongMaterial({
                        color: colors[slot],
                        emissive: colors[slot],
                        emissiveIntensity: 0.3
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(positions[slot], 0, 0);
                    sphere.castShadow = true;
                    sphere.userData = { property };
                    scene.add(sphere);

                    propertyModels[slot] = sphere;
                }

                // Store property data
                if (propertyModels[slot]) {
                    propertyModels[slot].userData = { property };
                }

                // Create overlays for this property
                createCrimeHeatmap(slot, property);
                createSchoolStars(slot, property);

                // Update sky color based on all loaded properties
                updateSkyColorForAllProperties();

                // Update winner effects
                updateWinnerEffects();
            };

            // ===== PROCEDURAL HOUSE GENERATION =====
            function createProceduralHouse(slot, property) {
                const positions = { A: -6, B: 0, C: 6 };
                const group = new THREE.Group();

                // Calculate dimensions based on sqft
                const baseSize = Math.sqrt(property.sqft) / 50;
                const width = baseSize * 1.5;
                const depth = baseSize;
                const height = 1.5 + (property.bedrooms * 0.3);

                // Main structure
                const bodyGeometry = new THREE.BoxGeometry(width, height, depth);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0xE8D9C5,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = height / 2;
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);

                // Roof
                const roofGeometry = new THREE.ConeGeometry(width * 0.8, height * 0.5, 4);
                const roofMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8B4513,
                    roughness: 0.9
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = height + (height * 0.25);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                group.add(roof);

                // Windows
                for (let i = 0; i < property.bedrooms; i++) {
                    const windowGeometry = new THREE.PlaneGeometry(0.3, 0.4);
                    const windowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x87CEEB,
                        transparent: true,
                        opacity: 0.6
                    });
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    window.position.set(-width/2 + (i * width / property.bedrooms), height * 0.5, depth/2 + 0.01);
                    group.add(window);
                }

                group.position.set(positions[slot], 0, 0);
                scene.add(group);

                propertyModels[slot] = group;
                propertyModels[slot].userData = { property };
            }

            // ===== OVERLAY SYSTEMS =====
            let overlays = {
                crime: { enabled: true, meshes: {} },
                schools: { enabled: true, meshes: {} },
                weather: { enabled: true, particles: null }
            };

            // Crime Heatmap System
            function createCrimeHeatmap(slot, property) {
                // Remove existing
                if (overlays.crime.meshes[slot]) {
                    scene.remove(overlays.crime.meshes[slot]);
                }

                if (!overlays.crime.enabled) return;

                const positions = { A: -6, B: 0, C: 6 };

                // Simulate crime data (0-100, higher = more crime)
                const crimeScore = property.crimeScore || Math.random() * 100;
                const crimeIntensity = crimeScore / 100;

                // Create danger zone circles
                const circleGroup = new THREE.Group();

                for (let i = 0; i < 3; i++) {
                    const radius = 2 + (i * 0.8) + (crimeIntensity * 2);
                    const geometry = new THREE.RingGeometry(radius - 0.1, radius + 0.1, 32);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xFF0000,
                        transparent: true,
                        opacity: (0.4 - (i * 0.1)) * crimeIntensity,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const ring = new THREE.Mesh(geometry, material);
                    ring.rotation.x = -Math.PI / 2;
                    ring.position.y = -1.98;
                    circleGroup.add(ring);
                }

                circleGroup.position.set(positions[slot], 0, 0);
                scene.add(circleGroup);
                overlays.crime.meshes[slot] = circleGroup;

                // Animate pulsing
                circleGroup.userData.animationOffset = Math.random() * Math.PI * 2;
            }

            // School Quality Stars System
            function createSchoolStars(slot, property) {
                // Remove existing
                if (overlays.schools.meshes[slot]) {
                    scene.remove(overlays.schools.meshes[slot]);
                }

                if (!overlays.schools.enabled) return;

                const positions = { A: -6, B: 0, C: 6 };

                // Simulate school data (1-5 stars)
                const schoolRating = property.schoolRating || Math.floor(Math.random() * 3) + 3;

                const starGroup = new THREE.Group();

                for (let i = 0; i < schoolRating; i++) {
                    // Create star using sprite
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');

                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚≠ê', 32, 32);

                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                    const star = new THREE.Sprite(material);
                    star.scale.set(0.5, 0.5, 1);
                    star.position.set((i - schoolRating / 2) * 0.6, 4, 0);
                    starGroup.add(star);
                }

                starGroup.position.set(positions[slot], 0, 0);
                scene.add(starGroup);
                overlays.schools.meshes[slot] = starGroup;

                // Animate floating
                starGroup.userData.animationOffset = Math.random() * Math.PI * 2;
            }

            // Weather Particle System
            function createWeatherSystem() {
                if (!overlays.weather.enabled) return;

                const particleCount = 1000;
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 40;
                    positions[i * 3 + 1] = Math.random() * 20;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
                }

                particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6
                });

                const particleSystem = new THREE.Points(particles, material);
                scene.add(particleSystem);
                overlays.weather.particles = particleSystem;
            }

            // Cost-of-Living Sky System
            function updateSkyColor(avgCostOfLiving) {
                // Green (low cost) -> Yellow (medium) -> Red (high cost)
                let skyColor;
                if (avgCostOfLiving < 33) {
                    skyColor = new THREE.Color(0x00FF88); // Green
                } else if (avgCostOfLiving < 67) {
                    skyColor = new THREE.Color(0xFFD700); // Yellow
                } else {
                    skyColor = new THREE.Color(0xFF4444); // Red
                }

                scene.background = scene.background.lerp(skyColor, 0.1);
                scene.fog.color.lerp(skyColor, 0.05);
            }

            function updateSkyColorForAllProperties() {
                // Calculate average cost of living across all loaded properties
                const loadedProperties = ['A', 'B', 'C']
                    .map(slot => {
                        const model = propertyModels[slot];
                        return model && model.userData && model.userData.property ? model.userData.property : null;
                    })
                    .filter(p => p !== null);

                if (loadedProperties.length === 0) return;

                const avgCostOfLiving = loadedProperties.reduce((sum, p) => sum + (p.costOfLiving || 50), 0) / loadedProperties.length;
                updateSkyColor(avgCostOfLiving);
            }

            // ===== WINNER EFFECTS SYSTEM =====
            let winnerDiamond = null;

            function updateWinnerEffects() {
                // Find all loaded properties with scores
                const loadedWithScores = ['A', 'B', 'C']
                    .map(slot => {
                        const model = propertyModels[slot];
                        const property = model && model.userData && model.userData.property ? model.userData.property : null;
                        return property ? { slot, property, model } : null;
                    })
                    .filter(p => p !== null && p.property.overallScore !== undefined);

                if (loadedWithScores.length < 2) {
                    // Need at least 2 properties to compare
                    clearWinnerEffects();
                    return;
                }

                // Find highest score
                const winner = loadedWithScores.reduce((best, current) => {
                    return current.property.overallScore > best.property.overallScore ? current : best;
                });

                // Clear previous winner effects
                clearWinnerEffects();

                // Apply winner effects to winning property
                applyWinnerEffects(winner.model, winner.slot);
            }

            function applyWinnerEffects(model, slot) {
                // 1. Apply 10% scale increase
                model.scale.set(1.1, 1.1, 1.1);

                // 2. Add golden glow to material
                if (model.material) {
                    model.material.emissive = new THREE.Color(0xFFD700);
                    model.material.emissiveIntensity = 0.5;
                }

                // 3. Create floating diamond sprite above property
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.font = 'bold 100px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üíé', 64, 64);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                winnerDiamond = new THREE.Sprite(spriteMaterial);
                winnerDiamond.scale.set(1.5, 1.5, 1);
                winnerDiamond.position.copy(model.position);
                winnerDiamond.position.y += 3;
                winnerDiamond.userData = { slot, initialY: winnerDiamond.position.y };
                scene.add(winnerDiamond);
            }

            function clearWinnerEffects() {
                // Reset all models to normal scale and glow
                ['A', 'B', 'C'].forEach(slot => {
                    const model = propertyModels[slot];
                    if (model) {
                        model.scale.set(1, 1, 1);
                        if (model.material) {
                            const colors = { A: 0x00D4FF, B: 0x00FF88, C: 0xFFD700 };
                            model.material.emissive = new THREE.Color(colors[slot]);
                            model.material.emissiveIntensity = 0.3;
                        }
                    }
                });

                // Remove diamond sprite
                if (winnerDiamond) {
                    scene.remove(winnerDiamond);
                    winnerDiamond = null;
                }
            }

            window.toggleOverlay = function(type, enabled) {
                overlays[type].enabled = enabled;

                if (type === 'crime') {
                    Object.keys(overlays.crime.meshes).forEach(slot => {
                        if (overlays.crime.meshes[slot]) {
                            overlays.crime.meshes[slot].visible = enabled;
                        }
                    });
                } else if (type === 'schools') {
                    Object.keys(overlays.schools.meshes).forEach(slot => {
                        if (overlays.schools.meshes[slot]) {
                            overlays.schools.meshes[slot].visible = enabled;
                        }
                    });
                } else if (type === 'weather') {
                    if (overlays.weather.particles) {
                        overlays.weather.particles.visible = enabled;
                    }
                }
            };

            // ===== VIEW MODE TOGGLE =====
            window.toggleViewMode = function() {
                viewMode = viewMode === 'sphere' ? '3d-model' : 'sphere';
                document.getElementById('mode-text').textContent =
                    viewMode === 'sphere' ? 'üè† 3D Model Mode' : 'üìä Sphere Mode';

                // Reload all properties in new mode
                ['A', 'B', 'C'].forEach(slot => {
                    const selectId = 'property' + slot;
                    const select = document.getElementById(selectId);
                    if (select.value) {
                        window.loadProperty(slot, select.value);
                    }
                });
            };

            // ===== VOICE COMMANDS =====
            function initializeVoiceCommands() {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.warn('Speech recognition not supported');
                    return;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.lang = 'en-US';
                recognition.interimResults = false;

                recognition.onstart = () => {
                    document.getElementById('voice-indicator').classList.add('active');
                };

                recognition.onend = () => {
                    document.getElementById('voice-indicator').classList.remove('active');
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase();
                    console.log('Voice command:', transcript);
                    handleVoiceCommand(transcript);
                };

                // Auto-start voice recognition
                try {
                    recognition.start();
                } catch (e) {
                    console.log('Voice recognition start failed:', e);
                }
            }

            function handleVoiceCommand(command) {
                // Property selection commands
                if (command.includes('show property') || command.includes('property')) {
                    if (command.includes('a') || command.includes('first')) {
                        zoomToProperty('A');
                    } else if (command.includes('b') || command.includes('second')) {
                        zoomToProperty('B');
                    } else if (command.includes('c') || command.includes('third')) {
                        zoomToProperty('C');
                    }
                }

                // Overview/reset command
                if (command.includes('show all') || command.includes('overview') || command.includes('reset view')) {
                    resetCamera();
                }

                // Zoom commands
                if (command.includes('zoom in')) {
                    zoomCamera(1.5);
                } else if (command.includes('zoom out')) {
                    zoomCamera(0.7);
                }

                // Rotation commands
                if (command.includes('rotate left')) {
                    rotateCamera(-Math.PI / 4);
                } else if (command.includes('rotate right')) {
                    rotateCamera(Math.PI / 4);
                }

                // Winner query
                if (command.includes('which is best') || command.includes('winner') || command.includes('highest score')) {
                    announceWinner();
                }
            }

            function zoomToProperty(slot) {
                const model = propertyModels[slot];
                if (!model) {
                    console.log(`Property ${slot} not loaded`);
                    return;
                }

                // Animate camera to property
                const targetPosition = model.position.clone();
                targetPosition.z += 5;
                targetPosition.y += 2;

                animateCameraTo(targetPosition, model.position);
            }

            function resetCamera() {
                const startPos = camera.position.clone();
                const startTarget = controls.target.clone();
                const endPos = new THREE.Vector3(0, 5, 15);
                const endTarget = new THREE.Vector3(0, 0, 0);

                animateCameraTo(endPos, endTarget);
            }

            function zoomCamera(factor) {
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, controls.target);
                direction.multiplyScalar(1 / factor);
                camera.position.copy(controls.target).add(direction);
            }

            function rotateCamera(angle) {
                const radius = camera.position.distanceTo(controls.target);
                const currentAngle = Math.atan2(camera.position.x, camera.position.z);
                const newAngle = currentAngle + angle;

                camera.position.x = Math.sin(newAngle) * radius;
                camera.position.z = Math.cos(newAngle) * radius;
            }

            function animateCameraTo(targetPos, targetLookAt) {
                const startPos = camera.position.clone();
                const startTarget = controls.target.clone();
                const duration = 1500;
                const startTime = Date.now();

                function animateStep() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic

                    camera.position.lerpVectors(startPos, targetPos, eased);
                    controls.target.lerpVectors(startTarget, targetLookAt, eased);

                    if (progress < 1) {
                        requestAnimationFrame(animateStep);
                    }
                }

                animateStep();
            }

            function announceWinner() {
                const loadedWithScores = ['A', 'B', 'C']
                    .map(slot => {
                        const model = propertyModels[slot];
                        const property = model && model.userData && model.userData.property ? model.userData.property : null;
                        return property ? { slot, property } : null;
                    })
                    .filter(p => p !== null && p.property.overallScore !== undefined);

                if (loadedWithScores.length === 0) {
                    console.log('No properties loaded');
                    return;
                }

                const winner = loadedWithScores.reduce((best, current) => {
                    return current.property.overallScore > best.property.overallScore ? current : best;
                });

                console.log(`Winner: Property ${winner.slot} - ${winner.property.name} (Score: ${winner.property.overallScore.toFixed(1)})`);
                zoomToProperty(winner.slot);
            }

            // ===== ANIMATION LOOP =====
            function animate() {
                requestAnimationFrame(animate);

                const time = Date.now() * 0.001;

                // Animate crime heatmap pulsing
                if (overlays.crime.enabled) {
                    Object.values(overlays.crime.meshes).forEach(group => {
                        if (group && group.userData.animationOffset !== undefined) {
                            const pulse = 1 + Math.sin(time * 2 + group.userData.animationOffset) * 0.1;
                            group.scale.set(pulse, 1, pulse);
                        }
                    });
                }

                // Animate school stars floating
                if (overlays.schools.enabled) {
                    Object.values(overlays.schools.meshes).forEach(group => {
                        if (group && group.children) {
                            group.children.forEach((star, idx) => {
                                const offset = idx * 0.5;
                                star.position.y = 4 + Math.sin(time + offset) * 0.2;
                            });
                        }
                    });
                }

                // Animate weather particles falling
                if (overlays.weather.enabled && overlays.weather.particles) {
                    const positions = overlays.weather.particles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] -= 0.05; // Fall down
                        if (positions[i + 1] < 0) positions[i + 1] = 20; // Reset to top
                    }
                    overlays.weather.particles.geometry.attributes.position.needsUpdate = true;
                }

                // Animate winner diamond bobbing
                if (winnerDiamond && winnerDiamond.userData.initialY !== undefined) {
                    winnerDiamond.position.y = winnerDiamond.userData.initialY + Math.sin(time * 2) * 0.3;
                }

                if (controls) controls.update();
                renderer.render(scene, camera);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            window.goBack = function() {
                window.location.href = '../index.html';
            };

            // Initialize on load
            window.addEventListener('DOMContentLoaded', init);
        })();
    </script>
</body>
</html>
